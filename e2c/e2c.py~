import numpy as np
import tensorflow as tf
import gym
import pdb
from tensorflow.keras import Model
from tensorflow.keras.layers import Dense, Flatten, Conv2D

def myModel(Model):
    def __init__(self,num_outputs):
        super(myModel, self).__init__()
        self.conv1 = Conv2D(batch_size, 3, activation='relu')
        self.flatten = Flatten()
        self.d1 = Dense(128, activation='relu')
        self.d2 = Dense(128, activation='relu')
        self.d3 = Dense(num_outputs) 

    def call(self, x):
        x = self.conv1(x)
        x = self.flatten(x)
        x = self.d1(x)
        x = self.d2(x)
        return self.d3(x)

def main():
    
    # initialize environment and deep model
    env = gym.make('CarRacing-v0')
    discrete = isinstance(env.action_space, gym.spaces.Discrete)
    ob_dim = env.observation_space.shape[0]
    ac_dim = env.action_space.n if discrete else env.action_space.shape[0]
    if discrete:
        loss_object = tf.keras.losses.MeanSquaredError()
    else:
        loss_object = tf.keras.losses.SparseCategoricalCrossEntropy()

    optimizer = tf.keras.optimizers.Adam()

    train_loss = tf.keras.metrics.Mean(name = 'train_loss')
    test_loss = tf.keras.metrics.Mean(name = 'test_loss')

    
    @tf.function
    def train_step(input, output, advantage):
        with tf.GradientTape() as tape:
            predictions = model(input)
            loss = loss_object(input, output, sample_weight=advantage)
        train_loss(loss)
    
    @tf.function
    def test_step():
        pass

    for episode in range(20)
        observation = env.reset()
        for t in range(10000):
            env.render()
            print(observation)
            #pdb.set_trace()
            action = env.action_space.sample()
            observation,reward,done,info = env.step(action)
            if done:
                print("Episode finished after {} timesteps".format(t+1))
                break
    env.close()

if __name__ == '__main__':
    main()
